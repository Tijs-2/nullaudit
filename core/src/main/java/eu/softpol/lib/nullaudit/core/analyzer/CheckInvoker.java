package eu.softpol.lib.nullaudit.core.analyzer;

import eu.softpol.lib.nullaudit.core.analyzer.CodeLocation.ClassLocation;
import eu.softpol.lib.nullaudit.core.analyzer.CodeLocation.PackageLocation;
import eu.softpol.lib.nullaudit.core.analyzer.visitor.context.NAClass;
import eu.softpol.lib.nullaudit.core.analyzer.visitor.context.NAPackage;
import eu.softpol.lib.nullaudit.core.check.Checker;
import eu.softpol.lib.nullaudit.core.check.ClassCheckContext;
import eu.softpol.lib.nullaudit.core.check.ClassChecker;
import eu.softpol.lib.nullaudit.core.check.PackageInfoCheckContext;
import eu.softpol.lib.nullaudit.core.check.PackageInfoChecker;
import eu.softpol.lib.nullaudit.core.report.Issue;
import eu.softpol.lib.nullaudit.core.report.Kind;
import eu.softpol.lib.nullaudit.core.report.ReportBuilder;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Optional;
import org.jspecify.annotations.Nullable;

public class CheckInvoker {

  private final AnalysisContext context;
  private final ReportBuilder reportBuilder;
  private final List<Checker> checks;
  private @Nullable NAPackage lastPackage;

  public CheckInvoker(AnalysisContext context, ReportBuilder reportBuilder, List<Checker> checks) {
    this.context = context;
    this.reportBuilder = reportBuilder;
    this.checks = checks;
  }

  public void checkPackage(NAPackage naPackage) {
    var packageLocation = new PackageLocation(context.getModuleName(), naPackage.packageName());
    var packageInfoCheckContext = new PackageInfoCheckContext(
        packageLocation,
        naPackage
    ) {
      @Override
      public void addIssue(CodeLocation location, Kind kind, String message) {
        appendIssue(location, kind, message);
      }
    };
    checks.stream()
        .filter(c -> c instanceof PackageInfoChecker)
        .map(c -> (PackageInfoChecker) c)
        .forEach(c -> c.checkPackage(packageInfoCheckContext));
    lastPackage = naPackage;
  }

  public void checkClass(NAClass naClass) {
    boolean unspecifiedNullnessFound = false;

    reportBuilder.incSummaryTotalClasses();

    var issues = new HashMap<CodeLocation, List<Kind>>();
    var classLocation = new ClassLocation(context.getModuleName(),
        naClass.thisClazz().packageName(), naClass.thisClazz().binarySimpleName());
    var naPackage = Optional.ofNullable(lastPackage)
        .filter(p -> p.packageName().equals(naClass.thisClazz().packageName()))
        .orElse(null);
    var classCheckContext = new ClassCheckContext(classLocation, naPackage, naClass) {
      @Override
      public void addIssue(CodeLocation codeLocation, Kind kind, String message) {
        appendIssue(codeLocation, kind, message);
        issues.computeIfAbsent(codeLocation, k -> new ArrayList<>())
            .add(kind);
      }
    };
    checks.stream()
        .filter(c -> c instanceof ClassChecker)
        .map(c -> (ClassChecker) c)
        .forEach(c -> c.checkClass(classCheckContext));

    for (var componentInfo : naClass.components()) {
      reportBuilder.incSummaryTotalFields();

      var l = classLocation.memberLocation(componentInfo.componentName());
      if (issues.getOrDefault(l, List.of()).contains(Kind.UNSPECIFIED_NULLNESS)) {
        reportBuilder.incSummaryUnspecifiedNullnessFields();
        unspecifiedNullnessFound = true;
      }
    }

    for (var fieldInfo : naClass.fields()) {
      if (naClass.isRecord()) {
        // generated by compiler - ignore
        continue;
      }
      reportBuilder.incSummaryTotalFields();

      var l = classLocation.memberLocation(fieldInfo.fieldName());
      if (issues.getOrDefault(l, List.of()).contains(Kind.UNSPECIFIED_NULLNESS)) {
        reportBuilder.incSummaryUnspecifiedNullnessFields();
        unspecifiedNullnessFound = true;
      }
    }

    for (var methodInfo : naClass.methods()) {
      reportBuilder.incSummaryTotalMethods();

      var l = classLocation.memberLocation(methodInfo.descriptiveMethodName());
      if (issues.getOrDefault(l, List.of()).contains(Kind.UNSPECIFIED_NULLNESS)) {
        reportBuilder.incSummaryUnspecifiedNullnessMethods();
        unspecifiedNullnessFound = true;
      }
    }

    if (unspecifiedNullnessFound) {
      reportBuilder.incSummaryUnspecifiedNullnessClasses();
    }
  }

  private void appendIssue(CodeLocation codeLocation, Kind kind, String message) {
    String location = "";
    if (codeLocation.module() != null) {
      location += codeLocation.module() + "/";
    }
    if (!codeLocation.packageName().isEmpty()) {
      location += codeLocation.packageName() + ".";
    }
    if (codeLocation instanceof CodeLocation.PackageLocation __) {
      location += "package-info";
    } else if (codeLocation instanceof CodeLocation.ClassLocation classLocation) {
      location += classLocation.className();
    } else if (codeLocation instanceof CodeLocation.MemberLocation memberLocation) {
      location += memberLocation.className() + "#" + memberLocation.memberName();
    } else {
      throw new IllegalArgumentException("Unsupported code location: " + codeLocation);
    }

    reportBuilder.addIssue(new Issue(
        location,
        kind,
        message
    ));
  }
}
