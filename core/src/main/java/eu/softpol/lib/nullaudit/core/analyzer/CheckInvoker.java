package eu.softpol.lib.nullaudit.core.analyzer;

import eu.softpol.lib.nullaudit.core.analyzer.CodeLocation.ClassLocation;
import eu.softpol.lib.nullaudit.core.analyzer.CodeLocation.PackageLocation;
import eu.softpol.lib.nullaudit.core.analyzer.visitor.context.NAClass;
import eu.softpol.lib.nullaudit.core.analyzer.visitor.context.NAComponent;
import eu.softpol.lib.nullaudit.core.analyzer.visitor.context.NAField;
import eu.softpol.lib.nullaudit.core.analyzer.visitor.context.NAMethod;
import eu.softpol.lib.nullaudit.core.analyzer.visitor.context.NAPackage;
import eu.softpol.lib.nullaudit.core.check.Checker;
import eu.softpol.lib.nullaudit.core.check.ClassCheckContext;
import eu.softpol.lib.nullaudit.core.check.ClassChecker;
import eu.softpol.lib.nullaudit.core.check.PackageInfoCheckContext;
import eu.softpol.lib.nullaudit.core.check.PackageInfoChecker;
import eu.softpol.lib.nullaudit.core.report.Issue;
import eu.softpol.lib.nullaudit.core.report.Kind;
import eu.softpol.lib.nullaudit.core.report.ReportBuilder;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public class CheckInvoker {

  private final AnalysisContext context;
  private final ReportBuilder reportBuilder;
  private final List<Checker> checks;

  public CheckInvoker(AnalysisContext context, ReportBuilder reportBuilder, List<Checker> checks) {
    this.context = context;
    this.reportBuilder = reportBuilder;
    this.checks = checks;
  }

  public void checkPackage(NAPackage naPackage) {
    var packageLocation = new PackageLocation(context.getModuleName(), naPackage.packageName());
    var packageInfoCheckContext = new PackageInfoCheckContext(
        packageLocation,
        naPackage
    ) {
      @Override
      public void addIssue(Kind kind, String message) {
        appendIssue(packageLocation, kind, message);
      }
    };
    checks.stream()
        .filter(c -> c instanceof PackageInfoChecker)
        .map(c -> (PackageInfoChecker) c)
        .forEach(c -> c.checkPackage(packageInfoCheckContext));
  }

  public void checkClass(NAClass naClass) {
    boolean unspecifiedNullnessFound = false;

    reportBuilder.incSummaryTotalClasses();

    var issuesForClass = new HashMap<String, List<Kind>>();
    var classLocation = new ClassLocation(context.getModuleName(),
        naClass.thisClazz().packageName(), naClass.thisClazz().binarySimpleName());
    var classCheckContext = new ClassCheckContext(classLocation, naClass) {
      @Override
      public void addIssueForClass(Kind kind, String message) {
        appendIssue(classLocation, kind, message);
      }

      @Override
      public void addIssueForField(NAField field, Kind kind, String message) {
        appendIssue(classLocation.memberLocation(field.fieldName()), kind, message);
        issuesForClass.computeIfAbsent(field.fieldName(), k -> new ArrayList<>())
            .add(kind);
      }

      @Override
      public void addIssueForComponent(NAComponent component, Kind kind, String message) {
        appendIssue(classLocation.memberLocation(component.componentName()), kind, message);
        issuesForClass.computeIfAbsent(component.componentName(), k -> new ArrayList<>())
            .add(kind);
      }

      @Override
      public void addIssueForMethod(NAMethod method, Kind kind, String message) {
        appendIssue(classLocation.memberLocation(method.descriptiveMethodName()), kind,
            message);
        issuesForClass.computeIfAbsent(method.descriptiveMethodName(), k -> new ArrayList<>())
            .add(kind);
      }
    };
    checks.stream()
        .filter(c -> c instanceof ClassChecker)
        .map(c -> (ClassChecker) c)
        .forEach(c -> c.checkClass(classCheckContext));

    for (var componentInfo : naClass.components()) {
      reportBuilder.incSummaryTotalFields();

      if (issuesForClass.getOrDefault(componentInfo.componentName(), List.of())
          .contains(Kind.UNSPECIFIED_NULLNESS)) {
        reportBuilder.incSummaryUnspecifiedNullnessFields();
        unspecifiedNullnessFound = true;
      }
    }

    for (var fieldInfo : naClass.fields()) {
      if (naClass.isRecord()) {
        // generated by compiler - ignore
        continue;
      }
      reportBuilder.incSummaryTotalFields();

      if (issuesForClass.getOrDefault(fieldInfo.fieldName(), List.of())
          .contains(Kind.UNSPECIFIED_NULLNESS)) {
        reportBuilder.incSummaryUnspecifiedNullnessFields();
        unspecifiedNullnessFound = true;
      }
    }

    for (var methodInfo : naClass.methods()) {
      reportBuilder.incSummaryTotalMethods();
      if (issuesForClass.getOrDefault(methodInfo.descriptiveMethodName(), List.of())
          .contains(Kind.UNSPECIFIED_NULLNESS)) {
        reportBuilder.incSummaryUnspecifiedNullnessMethods();
        unspecifiedNullnessFound = true;
      }
    }

    if (unspecifiedNullnessFound) {
      reportBuilder.incSummaryUnspecifiedNullnessClasses();
    }
  }

  private void appendIssue(CodeLocation codeLocation, Kind kind, String message) {
    String location = "";
    if (codeLocation.module() != null) {
      location += codeLocation.module() + "/";
    }
    if (!codeLocation.packageName().isEmpty()) {
      location += codeLocation.packageName() + ".";
    }
    if (codeLocation instanceof CodeLocation.PackageLocation __) {
      location += "package-info";
    } else if (codeLocation instanceof CodeLocation.ClassLocation classLocation) {
      location += classLocation.className();
    } else if (codeLocation instanceof CodeLocation.MemberLocation memberLocation) {
      location += memberLocation.className() + "#" + memberLocation.memberName();
    } else {
      throw new IllegalArgumentException("Unsupported code location: " + codeLocation);
    }

    reportBuilder.addIssue(new Issue(
        location,
        kind,
        message
    ));
  }
}
